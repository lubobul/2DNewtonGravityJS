

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta name="viewport" content="width=device-width" />

    <title>Gravity v1.0</title>
</head>

<body>

    <style>
        body {
            font-size: .85em;
            font-family: "Segoe UI", Verdana, Helvetica, Sans-Serif;
            color: #232323;
            background-color: #fff;
        }

        header, footer, nav, section {
            display: block;
        }

        /* Styles for basic forms
        -----------------------------------------------------------*/
        fieldset {
            border: 1px solid #ddd;
            padding: 0 1.4em 1.4em 1.4em;
            margin: 0 0 1.5em 0;
        }

        legend {
            font-size: 1.2em;
            font-weight: bold;
        }

        textarea {
            min-height: 75px;
        }

        .editor-label {
            margin: 1em 0 0 0;
        }

        .editor-field {
            margin: 0.5em 0 0 0;
        }

        h1 {
            display: block;
            font-size: 2em;
            -webkit-margin-before: 0.67em;
            -webkit-margin-after: 0.67em;
            -webkit-margin-start: 0px;
            -webkit-margin-end: 0px;
            font-weight: bold;
        }

        h3 {
            display: block;
            font-size: 1.17em;
            -webkit-margin-before: 1em;
            -webkit-margin-after: 1em;
            -webkit-margin-start: 0px;
            -webkit-margin-end: 0px;
            font-weight: bold;
        }

        h4 {
            display: block;
            -webkit-margin-before: 1.33em;
            -webkit-margin-after: 1.33em;
            -webkit-margin-start: 0px;
            -webkit-margin-end: 0px;
            font-weight: bold;
        }

        p {
            display: block;
            -webkit-margin-before: 1em;
            -webkit-margin-after: 1em;
            -webkit-margin-start: 0px;
            -webkit-margin-end: 0px;
        }

        .header4 {
            padding: 2px 0px 2px 0px;
            margin: 2px 0px 2px 0px;
            color: gray;
        }

        button.fractalize {
            cursor: pointer;
            padding: 5px 15px;
            margin-top: 10px;
            background: gray;
            border: 1px solid #585858;
            -moz-border-radius: 10px;
            -webkit-border-radius: 10px;
            border-radius: 3px;
            -webkit-box-shadow: 0 0 2px rgba(0,0,0, .75);
            -moz-box-shadow: 0 0 2px rgba(0,0,0, .75);
            box-shadow: 0 0 2px rgba(0,0,0, .75);
            color: #f3f3f3;
            font-size: 1.1em;
        }

        input.my-inputs {
            padding: 5px 15px;
            background: #f3f3f3;
            border: 1px solid #585858;
            -moz-border-radius: 10px;
            -webkit-border-radius: 10px;
            border-radius: 3px;
            width: 5.5em;
            -webkit-box-shadow: 0 0 2px rgba(0,0,0, .75);
            -moz-box-shadow: 0 0 2px rgba(0,0,0, .75);
            box-shadow: 0 0 2px rgba(0,0,0, .75);
            color: #000000;
            font-size: 1.1em;
        }

        input.extra-width {
            width: 14.6em;
        }

        button.fractalize:hover, button.fractalize:focus {
            background-color: #898989;
            -webkit-box-shadow: 0 0 1px rgba(0,0,0, .75);
            -moz-box-shadow: 0 0 1px rgba(0,0,0, .75);
            box-shadow: 0 0 1px rgba(0,0,0, .75);
        }

        #header {
            color: gray;
            margin: 0 auto 0 auto;
            text-align: center;
        }

        #footer {
            color: gray;
            margin: 0 auto 0 auto;
            text-align: center;
        }

        .menu {
            float: left;
            width: 165px;
            -webkit-box-shadow: 0 0 3px rgba(0,0,0, .75);
            -moz-box-shadow: 0 0 3px rgba(0,0,0, .75);
            box-shadow: 0 0 3px rgba(0,0,0, .75);
            padding: 5px;
            background-color: white;
        }

        .canvas-holder {
            float: left;
            width: auto;
            -webkit-box-shadow: 0 0 3px rgba(0,0,0, .75);
            -moz-box-shadow: 0 0 3px rgba(0,0,0, .75);
            box-shadow: 0 0 3px rgba(0,0,0, .75);
            background-color: white;
        }

        .menu-canvas-wrapper {
            width: 1800px;
            height: auto;
            margin-bottom: 2em;
        }

        .info {
            margin: 0px 2px 0px 2px;
            padding: 0px 2px 0px 2px;
            color: gray;
        }

        body {
            background-color: #fafafa;
        }

        .rule2-holder {
            width: 200px;
        }

        .rule2-checkbox-label {
            margin: 0px 2px 0px 2px;
            padding: 0px 2px 0px 2px;
            color: gray;
        }

        .menu-options {
            width: 1795px;
            height: 45px;
            background-color: transparent;
        }

        .menu-options-button {
            margin-right: 0.2em;
            float: left;
        }

        .my-popup {
            width: 500px;
            height: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            margin: -150px 0 0 -250px; /* [-(height/2)px 0 0 -(width/2)px] */
            padding: 1em;
            display: none;
            background: rgba(0,0,0, .8);
        }

        .close-poppup {
            float: right;
            border: none;
            background-color: white;
            cursor: pointer;
        }

        .close-poppup:hover {
            float: right;
            border: none;
            background-color: #f3f3f3;
            cursor: pointer;
        }

        p.text-rendering {
            color: white;
            padding: 2px 5px 0px 5px;
            margin: 0;
            font-size: 1.3em;
        }

        h4.stats {
            padding: 0px 0px 2px 2px;
            margin: 0px 0px 2px 2px;
            color: #83d53b;
            position: absolute;
            display: block;
            font-weight: normal !important;
            pointer-events: none !important;
        }

        .second-stat {
            margin-top: 1.2em !important;
        }

        .third-stat {
            margin-top: 2.4em !important;
        }
    </style>

    <h1 id="header">Welcome to Newton's law of universal gravitation N-body simulation v1.0</h1>

    <!--<h3 class="header4">Have fun!</h3>-->

    <div class="menu-canvas-wrapper">

        <div id="popup" class="my-popup">
            <button class="close-poppup" onclick="CloseAbout()">X</button>
            <h3 class="header4" style="color:white">Author </h3>
            <p style="color:white">Lyubomir Dimitrov Stoychev</p>
            <h3 class="header4" style="color:white">About </h3>
            <p style="color:white" class="about-info">This tool is written in pure JavaScript and is intended for experimenting with Newton's universal gravitation in 2D environment. Adding too many objects to the simulation may exeed the capabilities of your CPU, thus resulting in lower FPS. </p>
            <h3 class="header4" style="color:white">Goals for later versions</h3>
            <p style="color:white" class="about-info">Improve collision algorithm - (physics, size / mass transfer); Improve UI; </p>
            <p id="footer" style="color:white">Gravity v1.0 You are allowed to copy, distribute and modify the source as you wish. Just remember to give reference to the source.</p> <p id="footer" style="color:white">2016</p>
        </div>

        <div class="menu-options">

            <button class="fractalize menu-options-button" onclick="Sandbox()">Sandbox</button>
            <button class="fractalize menu-options-button" onclick="PlanetaryMode()">Planetary Mode</button>
            <button class="fractalize menu-options-button" onclick="Particles()">Particles 1</button>
            <button class="fractalize menu-options-button" onclick="Particles2()">Particles 2</button>
            <button class="fractalize menu-options-button" onclick="About()">About</button>

            <div class="menu-options-button">
                <h4 style="padding-top:1.3em; padding-left:1em;" class="header4">Tips: for new object - drag & drop; For object stats - right click on object;</h4>
            </div>
        </div>

        <div class="menu">

            <h3 class="header4">Controls</h3>


            <div style="width:300px;">
                <h4 class="header4">Speed controls </h4>
                <button class="fractalize" onclick="Slower()">/2</button>
                <button class="fractalize" onclick="Faster()">x2</button>
            </div>

            <div style="width:300px;">
                <h4 class="header4">Play controls</h4>
                <button class="fractalize" id="pause-unpause" onclick="PauseUnpause()">Pause</button>
                <button class="fractalize" id="pause-unpause" onclick="ResetSimulation()">Reset</button>
            </div>
            <div style="width:300px;">
                <h4 class="header4">Static objects</h4>
                <input id="static-objects" onclick="ChangeStaticObjectsState()" type="checkbox" />
                <label class="rule2-checkbox-label" id="static-objects-checkbox-label">Disabled</label>
            </div>

            <div style="width:300px;">
                <h4 class="header4">Clamped object distance</h4>
                <input id="clamped-distance" onclick="ChangeClampedDistanceState()" type="checkbox" />
                <label class="rule2-checkbox-label" id="clamped-distance-checkbox-label">Disabled</label>
            </div>

            <div style="width:300px;" id="traces-holder">
                <h4 class="header4">Traces (experimental)</h4>
                <input id="object-traces" onclick="ChangeTracesState()" type="checkbox" />
                <label class="rule2-checkbox-label" id="object-traces-checkbox-label">Disabled</label>
            </div>

            <div style="width:300px;">
                <h4 class="header4">Collision (experimental)</h4>
                <input id="collision" onclick="ChangeCollisionState()" type="checkbox" />
                <label class="rule2-checkbox-label" id="object-collision-checkbox-label">Disabled</label>
            </div>

            <div style="width:300px;">
                <h4 class="header4">Object option</h4>
                <select style="width:150px" name="objects" id="selected-object" onChange="SelectObject(this.value)">
                    <option value="moon">Moon</option>
                    <option value="earth">Earth</option>
                    <option value="jupiter">Jupiter</option>
                    <option value="sun">Sun</option>
                </select>
            </div>

            <div style="width:300px; display:none;" id="object-stats-holder">
                <h4 style="position:relative;" class="stats" id="object-velocity-x">Velocity X: m/s</h4>
                <h4 style="position:relative;" class="stats" id="object-velocity-y">Velocity Y: m/s</h4>
                <h4 style="position:relative;" class="stats" id="object-speed">Speed: m/s</h4>
            </div>

        </div>

        <div class="canvas-holder" style="background-color:white;" oncontextmenu="return false;">

            <h4 class="stats" id="speed">Speed: </h4>
            <h4 class="stats second-stat" id="days">Days: </h4>
            <h4 class="stats third-stat" id="fps">FPS: </h4>

            <canvas id="canvas" width="1620" height="800" tabindex="0"></canvas>
        </div>

    </div>

    <script>
        'use strict'

        window.onload = function ()
        {
            InvertCanvasAxis();

            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;

            InitXYAxis();
            SelectObject('moon');
        }

        window.requestAnimFrame = (function (callback) {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();

        //Ui controls

        function About()
        {
            var popup = document.getElementById("popup");
            popup.style.display = 'block';
        }

        function CloseAbout()
        {
            var popup = document.getElementById("popup");
            popup.style.display = 'none';
        }

        //increase speed simulation by a factor of 2
        function Faster()
        {
            elapsedTimeInRealLifePerSec *= 2;

            UpdateSpeed();
        }

        //decrease speed simulation by a factor of 2
        function Slower()
        {
            elapsedTimeInRealLifePerSec /= 2;

            UpdateSpeed();
        }

        function PauseUnpause()
        {
            if (isSimulationRunning)
                document.getElementById("pause-unpause").innerHTML = "Unpause";
            else
                document.getElementById("pause-unpause").innerHTML = "Pause";

            isSimulationRunning = !isSimulationRunning;
        }

        var reset_delegate = Sandbox;

        function ResetSimulation()
        {
            reset_delegate();
        }

        function ChangeStaticObjectsState()
        {
            static_objects_state = document.getElementById("static-objects").checked;

            if (static_objects_state)
            {
                document.getElementById("static-objects-checkbox-label").innerHTML = "Enabled";
            }
            else
            {
                document.getElementById("static-objects-checkbox-label").innerHTML = "Disabled";
            }
        }

        function ChangeClampedDistanceState()
        {
            is_distance_between_objects_clamped = document.getElementById("clamped-distance").checked;

            if (is_distance_between_objects_clamped) {
                document.getElementById("clamped-distance-checkbox-label").innerHTML = "Obj1.r + Obj2.r";
            }
            else {
                document.getElementById("clamped-distance-checkbox-label").innerHTML = "Disabled";
            }
        }

        function ChangeTracesState()
        {
            traceIsOn = document.getElementById("object-traces").checked;

            if (traceIsOn)
            {
                document.getElementById("object-traces-checkbox-label").innerHTML = "Enabled";
            }
            else
            {
                document.getElementById("object-traces-checkbox-label").innerHTML = "Disabled";
            }
        }

        function ChangeCollisionState()
        {
            is_colision_mode_on = document.getElementById("collision").checked;

            if (is_colision_mode_on)
            {
                document.getElementById("object-collision-checkbox-label").innerHTML = "Enabled";
            }
            else
            {
                document.getElementById("object-collision-checkbox-label").innerHTML = "Disabled";
            }
        }

        function HideTracesOption()
        {
            var popup = document.getElementById("traces-holder");
            popup.style.display = 'none';
        }

        function ShowTracesOption()
        {
            var popup = document.getElementById("traces-holder");
            popup.style.display = 'block';
        }

        function HideObjectStats()
        {
            var popup = document.getElementById("object-stats-holder");
            popup.style.display = 'none';
        }

        function ShowObjectStats()
        {
            var popup = document.getElementById("object-stats-holder");
            popup.style.display = 'block';
        }


        function ResetUiControls()
        {
            document.getElementById("pause-unpause").innerHTML = "Pause";

            document.getElementById("static-objects").checked = false;
            document.getElementById("static-objects-checkbox-label").innerHTML = "Disabled";

            document.getElementById("object-traces").checked = false;

            HideObjectStats();

            setTimeout(UpdateSpeed, 10);
        }

        var selected_object = undefined;

        //Change selected object for adding it into the simulation via drag&drop
        function SelectObject(value)
        {
            if (value == 'earth') {
                selected_object = {
                    color: "blue",
                    diameter: 12742000,
                    //substracting offset because adding it when rendering
                    x: 0,
                    y: 0,
                    v_x: 0,
                    v_y: 0,
                    mass: 5.972 * Math.pow(10, 24)
                }

            }
            else if (value == 'jupiter') {
                selected_object = {
                    color: "orange",
                    diameter: 139822000 / 10,
                    //substracting offset because adding it when rendering
                    x: 0,
                    y: 0,
                    v_x: 0,
                    v_y: 0,
                    mass: 1.898 * Math.pow(10, 27)
                }
            }
            else if (value == 'sun') {
                selected_object = {
                    color: "yellow",
                    diameter: 1391400000 / 30,
                    //substracting offset because adding it when rendering
                    x: 0,
                    y: 0,
                    v_x: 0,
                    v_y: 0,
                    mass: 1.989 * Math.pow(10, 30)
                }
            } else if (value == 'moon') {
                selected_object = {
                    color: "grey",
                    diameter: 3474000,
                    //substracting offset because adding it when rendering
                    x: 0,
                    y: 0,
                    v_x: 0,
                    v_y: 0,
                    mass: 7.342 * Math.pow(10, 22)
                }
            }
        }

        //utill

        //Degrees to radians
        function DegToRad(deg)
        {
            return (Math.PI / 180) * deg;
        }

        //Rectangular to polar coordinates 
        function RectToPolar(x, y)
        {
            var r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            var t = Math.atan2(y, x);

            return { r, t }
        }

        //Canvas Mouse controls
        var offsetX = 0;
        var offsetY = 0;

        var c = document.getElementById("canvas");
        var ctx = c.getContext("2d");

        //Get Canvas Coordinates on click
        canvas.addEventListener("mousedown", MouseDown, false);
        canvas.addEventListener("mouseup", MouseUp, false);

        //Gets the coordinates of a click over the canvas ( will be used in future for object creation, drag and drop etc.)
        function MouseDown(e)
        {
            if (e.button === 2)
            { //right click 
                ShowStatsForObject(e);
            }
            else
            {
                object_vector_start_x = GetMouseCoordinates(e).x;
                object_vector_start_y = GetMouseCoordinates(e).y;
                object_vector_direction_x = object_vector_start_x;
                object_vector_direction_y = object_vector_start_y;

                canvas.addEventListener("mousemove", MouseMove, false);
            }
        }

        function MouseUp(e) {
            if (e.button === 2)
            { 
                //right click
            } else
            {
                canvas.removeEventListener("mousemove", MouseMove, false);
                InsertNewObjectIntoTheSimulation();
            }
        }

        function MouseMove(e) {

            object_vector_direction_x = GetMouseCoordinates(e).x;
            object_vector_direction_y = GetMouseCoordinates(e).y;
        }

        function GetMouseCoordinates(e)
        {
            var x;
            var y;

            if (e.pageX || e.pageY)
            {
                x = e.pageX;
                y = e.pageY;
            }
            else
            {
                x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }

            x -= c.offsetLeft;
            y -= c.offsetTop;

            y = c.height - y; //invert y axis (click coordinates are not affected when inverting canvas axis)


            return { x: x, y: y }
        }

        //Invert canvas
        function InvertCanvasAxis()
        {
            ctx.transform(1, 0, 0, -1, 0, canvas.height);
        }

        //Draw a line from posX,posY to posXto, posYto with offset
        function DrawPixel(x, y)
        {
            ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
        }

        //Draw a line from posX,posY to posXto, posYto without offset
        function DrawLineNoOffset(posX, posY, posXto, posYto)
        {
            ctx.beginPath();
            ctx.moveTo(posX, posY);
            ctx.lineTo(posXto, posYto);
            ctx.closePath();
            ctx.stroke();
        }

        //Draws an oval object
        function DrawObject(posX, posY, radius, color)
        {
            ctx.setLineDash([0, 0]);
            ctx.beginPath();
            ctx.arc(offsetX + posX, offsetY + posY, radius, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        //Draws the X Y dahsed AXIS
        function InitXYAxis()
        {
            ctx.setLineDash([1, 2]);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "green";
            DrawLineNoOffset(0, canvas.height / 2, canvas.width, canvas.height / 2);
            DrawLineNoOffset(canvas.width / 2, 0, canvas.width / 2, canvas.height);
        }

        //Draws vector of drag-drop adding new object
        function NewObjectDirectionVector()
        {
            ctx.setLineDash([0, 0]);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "red";
            DrawLineNoOffset(object_vector_start_x, object_vector_start_y, object_vector_direction_x, object_vector_direction_y);
        }

        //Clears the canvas
        function ClearCanvas()
        {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        var fps_element = document.getElementById("fps");
        //Update fps element
        function UpdateFps()
        {
            fps_element.innerHTML = "FPS: " + Math.round(fps);
        }

        var days_element = document.getElementById("days");
        //Update days element
        function UpdateDays()
        {
            days_element.innerHTML = "Days: " + Math.round(days * 100) / 100;
        }

        var speed_element = document.getElementById("speed");
        //Update speed element
        function UpdateSpeed()
        {
            speed_element.innerHTML = "Speed: " + elapsedTimeInRealLifePerSec + "x";
        }

        var obj_velocity_x_element = document.getElementById("object-velocity-x");
        var obj_velocity_y_element = document.getElementById("object-velocity-y");
        var obj_speed_element = document.getElementById("object-speed");

        //Update object stats
        function UpdateObjectStats()
        {
            obj_velocity_x_element.innerHTML = "Velocity X: " + Math.round(initObjects[selected_object_for_stats_index].v_x) + "m/s";
            obj_velocity_y_element.innerHTML = "Velocity Y: " + Math.round(initObjects[selected_object_for_stats_index].v_y) + "m/s";
            obj_speed_element.innerHTML = "Speed: " + Math.round(Math.sqrt(Math.pow(initObjects[selected_object_for_stats_index].v_x, 2)
                + Math.pow(initObjects[selected_object_for_stats_index].v_y, 2))) + "m/s";
        }

        

        var object_vector_direction_x = 0;
        var object_vector_direction_y = 0;

        var object_vector_start_x = 0;
        var object_vector_start_y = 0;

        //Keep this as a constant
        var SECONDS_PER_DAY = 86400;

        var distance_factor = 0; //Objects distance factor - 1 pix = 1 meter
        var size_factor = 0; //Objects size factor - 1pix = 1 meter 

        function PlanetaryMode()
        {
          
            ShowTracesOption();

            reset_delegate = PlanetaryMode;

            ClearSimulationVariables();

            TRACE_LENGTH = 600;

            distance_factor = 800000000;
            size_factor = 1000000;
            new_object_velocity_factor = 5000;

            //Sun
            var body1 = {
                color: "yellow",
                diameter: 1391400000/30,
                x: 0,
                y: 0,
                v_x: 0,
                v_y: 0,
                mass: 1.989 * Math.pow(10, 30)
            }

            //Mercury
            var body2 = {
                color: "grey",
                diameter: 4879000,
                x: 0,
                y: 57910000000,
                v_x: 48000 * Math.cos(DegToRad(0)),
                v_y: 48000 * Math.sin(DegToRad(0)),
                mass: 3.285 * Math.pow(10, 23)
            }

            //Venus
            var body3 = {
                color: "orange",
                diameter: 12104000,
                x: 0,
                y: 108200000000,
                v_x: 35020 * Math.cos(DegToRad(0)),
                v_y: 35020 * Math.sin(DegToRad(0)),
                mass: 4.867 * Math.pow(10, 24)
            }

            //Earth
            var body4 = {
                color: "blue",
                diameter: 12742000,
                x: 0,
                y: 149600000000,
                v_x: 29800 * Math.cos(DegToRad(0)),
                v_y: 29800 * Math.sin(DegToRad(0)),
                mass: 5.972 * Math.pow(10, 24)
            }

            //mars
            var body5 = {
                color: "red",
                diameter: 6779000,
                x: 0,
                y: 227900000000,
                v_x: 24077 * Math.cos(DegToRad(0)),
                v_y: 24077 * Math.sin(DegToRad(0)),
                mass: 6.39 * Math.pow(10, 23)
            }

            //Jupiter
            var body6 = {
                color: "orange",
                diameter: 139822000,
                x: 0,
                y: 778500000000,
                v_x: 13070 * Math.cos(DegToRad(0)),
                v_y: 13070 * Math.sin(DegToRad(0)),
                mass: 1.898 * Math.pow(10, 27)
            }


            //Mercury to Jupiter real simulation
            initObjects.push(body1);
            initObjects.push(body2);
            initObjects.push(body3);
            initObjects.push(body4);
            initObjects.push(body5);
            //initObjects.push(body6);

            isSimulationStopped = true;
            setTimeout(BeginSimulation, 100);
        }

        function Sandbox()
        {
            ShowTracesOption();

            reset_delegate = Sandbox;

            ClearSimulationVariables();

            elapsedTimeInRealLifePerSec = SECONDS_PER_DAY / 4;

            new_object_velocity_factor = 50;
            distance_factor = 1000000;
            size_factor = 1000000;

            isSimulationStopped = true;
            setTimeout(BeginSimulation, 100);
        }

        function Particles()
        {
            HideTracesOption();

            reset_delegate = Particles;

            ClearSimulationVariables();

            elapsedTimeInRealLifePerSec = SECONDS_PER_DAY / 20;

            new_object_velocity_factor = 50;
            distance_factor = 1000000;
            size_factor = 1000000;

            var obj_per_width = 25;
            var obj_per_height = 25;

            var new_particle = {};

            for (var i = 1; i <= obj_per_width; i++)
            {
                for (var j = 1; j <= obj_per_height; j++)
                {
                    new_particle = {
                        color: "black",
                        diameter: 3474000,
                        x: (((canvas.width / obj_per_width) * i) - offsetX) * distance_factor,
                        y: (((canvas.height / obj_per_height) * j) - offsetY) * distance_factor,
                        v_x: 0,
                        v_y: 0,
                        mass: 7.35 * Math.pow(10, 24)
                    }

                    initObjects.push(new_particle);
                }
            }

            isSimulationStopped = true;
            setTimeout(BeginSimulation, 100);

            setTimeout(PauseUnpause, 100);
        }

        function Particles2()
        {
            HideTracesOption();

            reset_delegate = Particles2;

            ClearSimulationVariables();

            elapsedTimeInRealLifePerSec = SECONDS_PER_DAY / 20;

            new_object_velocity_factor = 50;
            distance_factor = 1000000;
            size_factor = 1000000;

            var obj_per_width = 25;
            var obj_per_height = 25;

            var new_particle = {};

            for (var i = 1; i <= obj_per_width; i++)
            {
                for (var j = 1; j <= obj_per_height; j++)
                {
                    new_particle = {
                        color: "black",
                        diameter: 3474000,
                        x: (((canvas.height / 4 / obj_per_width) * i) - offsetY / 4) * distance_factor,
                        y: (((canvas.height / 4 / obj_per_height) * j) - offsetY / 4) * distance_factor,
                        v_x: 0,
                        v_y: 0,
                        mass: 7.35 * Math.pow(10, 22)
                    }

                    initObjects.push(new_particle);
                }
            }

            isSimulationStopped = true;
            setTimeout(BeginSimulation, 100);

            setTimeout(PauseUnpause, 100);
        }

        //Initi drawing function
        function BeginSimulation(isPaused)
        {
            isSimulationStopped = false;

            var startTime = (new Date()).getTime();

            ClearCanvas();
            InitXYAxis();

            isSimulationRunning = !isPaused;
            Animate(canvas, ctx, startTime);
        }

        //Reset simulation variables, including UI linked settings
        function ClearSimulationVariables()
        {
            isSimulationStopped = true;
            isSimulationRunning = false;

            traceIsOn = false;

            fps = 0;

            TRACE_LENGTH = 180;

            elapsedTimeInRealLifePerSec = 86400; //86400 secs = 1 day

            days = 0;
            addTracePoint = 0;
            initObjects = [];

            static_objects_state = false;
            statsAreOn = false;
            
            ResetUiControls();
     
        }

        var isSimulationStopped = true;
        var isSimulationRunning = false;

        var traceIsOn = false;
        var statsAreOn = false;

        var fps = 0;

        var prevTimeLog;

        //Change this to run simulation faster / slower
        var elapsedTimeInRealLifePerSec = 86400; //86400 secs = 1 day
        var delta_time;
        var days = 0;
        var addTracePoint = 0;

        //Recursive funtcion called once per frame
        function Animate(canvas, ctx)
        {
            if (!prevTimeLog)
            {
                prevTimeLog = new Date().getTime();

                requestAnimFrame(function ()
                {
                    Animate(canvas, ctx);

                });

                return;
            }

            delta_time = (new Date().getTime() - prevTimeLog) / 1000;

            prevTimeLog = new Date().getTime()

            //calc fps
            fps = 1 / delta_time;

            UpdateFps(fps);

            // t - time between calculting new positions
            t = elapsedTimeInRealLifePerSec * delta_time;

            ClearCanvas();
            InitXYAxis();

            NewObjectDirectionVector();

            if (isSimulationRunning)
            {
                CalculateDynamics();
            }

            DrawMultipleObejcts();
            UpdateDays();

            if(statsAreOn) UpdateObjectStats()

            if (traceIsOn) DrawTraces();

            if (!isSimulationStopped)
            {
                requestAnimFrame(function ()
                {
                    Animate(canvas, ctx);
                });
            }
        }

        var alpha = 0.0;
        var fraction;
        var trace;

        //Draw multiple traces, trace = [object][trace]
        function DrawTraces()
        {
            alpha = 0.0;

            fraction = (0.3 / objectTraceStack.length);

            //Traces
            for (var i = 0, len = objectTraceStack.length; i < len; i++)
            {
                alpha += fraction;
                ctx.fillStyle = "rgba(0,0,0," + alpha + ")"; //dim trace at tail

                //Trace
                trace = objectTraceStack[i];
                //Objects
                for (var j = 0; j < trace.length; j++)
                {
                    DrawPixel(trace[j].x, trace[j].y);
                }
            }
        }

        var objects_i;
        var object_to_draw;
        //draw multiple objects
        function DrawMultipleObejcts()
        {
            for (objects_i = 0; objects_i < initObjects.length; objects_i++)
            {
                object_to_draw = initObjects[objects_i];
                DrawObject(object_to_draw.x / distance_factor, object_to_draw.y / distance_factor, (object_to_draw.diameter / 2) / size_factor, object_to_draw.color);
            }
        }

        var selected_object_for_stats_index = 0;

        //called once per right click on canvas, if object under mouse, select it to show stats, else hide stats
        function ShowStatsForObject(e)
        {
            var coordinates = GetMouseCoordinates(e);

            var r = 0;

            for (var i = 0, len = initObjects.length; i < len; i++)
            {
                r = Math.sqrt(Math.pow(((initObjects[i].x / distance_factor) - (coordinates.x - offsetX)), 2) + Math.pow(((initObjects[i].y / distance_factor) - (coordinates.y - offsetY)), 2));

                if (r <= (initObjects[i].diameter / size_factor) / 2 + 1)
                {
                    selected_object_for_stats_index = i;

                    ShowObjectStats();
                    statsAreOn = true;
                    return;
                }
            }

            statsAreOn = false;
            HideObjectStats();
        }

        var new_object_velocity_factor = 1;

        //Inserts a UI selected object into the simulation, calculating direction ad speed proportional to the created drag & drop vector
        function InsertNewObjectIntoTheSimulation()
        {
            //substracting start x and y from direction x and y to get 0.0 to x.y,
            //have in mind that coordinate system starts from X0/Y0 therefore always X >0 & Y >0 and it is OK to substract coordinates like this
            var polar_coordinates = RectToPolar(object_vector_direction_x - object_vector_start_x, object_vector_direction_y - object_vector_start_y);

            var v = (polar_coordinates.r * new_object_velocity_factor); //linear progression of velocity based on vector length (needs to be figured out properly)

            var new_obj =
            {
                color: selected_object.color,
                diameter: selected_object.diameter,
                //substracting offset because adding it when rendering
                x: (object_vector_start_x - offsetX) * distance_factor,
                y: (object_vector_start_y - offsetY) * distance_factor,
                v_x: v * Math.cos(polar_coordinates.t),
                v_y: v * Math.sin(polar_coordinates.t),
                mass: selected_object.mass
            }

            object_vector_direction_x =
                object_vector_start_x =
                object_vector_direction_y =
                object_vector_start_y = 0;


            initObjects.push(new_obj);
        }

        //That's where all dynamic calculations occur, called in a specific order
        function CalculateDynamics()
        {
            ////Takes a lot of CPU - enable only for a single object...
            ////attempting to get long traces when slower
            if (traceIsOn) CalculateTraces();

            CalculateMultipleObjects();

            days += (delta_time * elapsedTimeInRealLifePerSec) / SECONDS_PER_DAY;
        }

        var objectTraceStack = [];
        //lenght of trace behind objects in number of kept calcukated positions
        var TRACE_LENGTH = 180;

        //calculate multiple traces
        function CalculateTraces()
        {
            if (objectTraceStack.length > TRACE_LENGTH)
                objectTraceStack.shift(); //rem last

            var traces = [];

            for (var i = 0, len = initObjects.length; i < len; i++)
            {
                if (initObjects[i].v_x != 0 || initObjects[i].v_y != 0)
                {
                    traces.push({
                        x: initObjects[i].x / distance_factor,
                        y: initObjects[i].y / distance_factor
                    });
                }
            }

            objectTraceStack.push(traces);
        }

        var initObjects = [];

        var tmp_F;
        var currentObject;

        //Net force mussed be calculated for each object compared to each of the rest of objects (sum of all forces applied to a particular object)
        var net_F_x;
        var net_F_y;
        var new_objects = [];

        var numOfObjects;

        var static_objects_state = false;
        var i;
        var new_i;
        
        //This is the main function for calculating N object interaction, called 1ce per frame
        function CalculateMultipleObjects()
        {
            new_objects = [];

            numOfObjects = initObjects.length;

            for (i = 0; i < numOfObjects; i++)
            {
                currentObject = initObjects[i];

                if (currentObject != null)
                {
                    net_F_x = 0;
                    net_F_y = 0;
                    tmp_F = undefined;

                    //check if an object is static, skip calculations if true
                    if (currentObject.v_x != 0 || currentObject.v_y != 0)
                    {
                        CalculateObjectInteraction(i);
                    }
                    else if (!static_objects_state)
                    {
                        CalculateObjectInteraction(i);
                    }

                    new_objects.push(currentObject);

                    initObjects[i] = currentObject;
                }
              
            }

            initObjects = [];

            for (new_i = 0; new_i < new_objects.length; new_i++)
            {
                if (new_objects[new_i] != null)
                    initObjects.push(new_objects[new_i]);
            }
        }

        var j;
        var secondObject = undefined;
        var distance_bodies_0 = 0;
        var distance_bodies_1 = 0;
        var is_colision_mode_on = false;
        var is_distance_between_objects_clamped = false;

        var colided_objects = undefined;

        //All object iteraction goes here
        function CalculateObjectInteraction(i)
        {

            for (j = 0; j < numOfObjects; j++)
            {
                secondObject = initObjects[j];

                if (secondObject != null)
                   {
                    //Distance between movingBody / staticBody
                    distance_bodies_0 = distance_bodies_1 = Math.sqrt(Math.pow((currentObject.x - secondObject.x), 2) + Math.pow((currentObject.y - secondObject.y), 2));

                    //don't compare to self
                    if (i != j) {

                        //clamp closest distance between 2 objects
                        if ((currentObject.diameter / 2 + secondObject.diameter / 2) > distance_bodies_0 && is_distance_between_objects_clamped)
                            distance_bodies_0 = (currentObject.diameter / 2) + (secondObject.diameter / 2);

                        tmp_F = CalcForce2Bodies(currentObject, secondObject, distance_bodies_0);

                        //calculate netforce for object i
                        net_F_x += tmp_F.F_x;
                        net_F_y += tmp_F.F_y;

                        //Colision
                        if (is_colision_mode_on)
                        {
                            if (currentObject.mass < secondObject.mass)
                            {
                                colided_objects = CalculateCollision(secondObject, currentObject, distance_bodies_1);

                                if (colided_objects != null)
                                {
                                    currentObject = colided_objects.smallBody;
                                    secondObject = colided_objects.bigBody;
                                }
                            }
                            else
                            {
                                colided_objects = CalculateCollision(currentObject, secondObject, distance_bodies_1);

                                if (colided_objects != null)
                                {
                                    secondObject = colided_objects.smallBody;
                                    currentObject = colided_objects.bigBody;
                                }
                            }

                            initObjects[j] = secondObject;

                            if (currentObject == null)
                            {
                                return;
                            }
                        }
                    }
                }
            }

            currentObject = CalcCoordinates2Bodies(currentObject, net_F_x, net_F_y);
        }

        //Calculate if collision occurs, transfer mass and size if so
        function CalculateCollision(bigBody, smallBody, distance)
        {
            //checking out if collision occured r0 + r1 < distance
            if ((bigBody.diameter / 2 + smallBody.diameter / 2) < distance) return null;

            var affected_area_length = 0;

            if (bigBody.diameter < distance) //center of small circle is outside the big circle
            {
                affected_area_length = Math.abs(distance - ((smallBody.diameter / 2) + (bigBody.diameter / 2)));
            }
            else if(distance + smallBody.diameter/2 <= bigBody.diameter/2) //the whole small one is inside the big one
            {
                affected_area_length = smallBody.diameter;
            }
            else// the center of the small is inside the big, but portion of it is outside
            {
                affected_area_length = Math.abs(((bigBody.diameter / 2) - distance) + (smallBody.diameter / 2));
            }

            var affected_body_factor = affected_area_length / smallBody.diameter;

            var mass_to_transfer = smallBody.mass * affected_body_factor;

            if (affected_body_factor >= 1.0) //if smallBody has been eaten, set it to null so we avoid negative radiuses, it is later removed from the simulation
            {
                bigBody.mass = bigBody.mass + smallBody.mass;
                smallBody = null;
            }
            else
            {
                bigBody.mass = bigBody.mass + mass_to_transfer;
                smallBody.mass = smallBody.mass - mass_to_transfer;
                smallBody.diameter = smallBody.diameter - affected_area_length;
            }

            //Diameter exchange from small ot big body limited to 1/6th since
            //Later I would try and transfer surface area instead
            bigBody.diameter = bigBody.diameter + (affected_area_length/6); 

            return {
                smallBody: smallBody,
                bigBody: bigBody
            };
        }

        //Newton's gravitational constant
        var G = 6.674 * Math.pow(10, -11);

        //Elapsed time between 2 points in 2D space betweem the "static" and the moving object
        var t = 1; //seconds

        function CalcForce2Bodies(movingBody, staticBody, r)
        {
            // Fgrav = G*M*m/r^2
            var F = (G * staticBody.mass * movingBody.mass) / (Math.pow(r, 2));

            //Calculating Force for x and y

            var delta_x = staticBody.x - movingBody.x;
            var detla_y = staticBody.y - movingBody.y;

            var F_x = F * (delta_x / r);
            var F_y = F * (detla_y / r);

            return { F_x, F_y }
        }

        //Calculates new coordinates and velocities of a moving body based on net force and elapsed time
        function CalcCoordinates2Bodies(movingBody, net_F_x, net_F_y)
        {
            var a_x = net_F_x / movingBody.mass;
            var a_y = net_F_y / movingBody.mass;

            //Calculating new velocities
            movingBody.v_x = movingBody.v_x + (a_x * t);
            movingBody.v_y = movingBody.v_y + (a_y * t);

            //Calculating new x y coordinates for the moving body
            movingBody.x = (movingBody.x + movingBody.v_x * t);
            movingBody.y = (movingBody.y + movingBody.v_y * t);

            return movingBody;
        }

    </script>
</body>
</html>